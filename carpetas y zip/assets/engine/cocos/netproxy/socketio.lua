local socketIO = class('SocketIO')
local _onWebSocketMsgHandler = nil
local _webSocketSendString = nil
local _sbyteFunc = string.byte
local _ssubFunc = string.sub
local _tconcatFunc = table.concat
-----------------socketIO Key Messsage Head------------------------------

local _frame_open_key = _sbyteFunc("0")
local _frame_close_key = _sbyteFunc("1")
local _frame_ping_key = _sbyteFunc("2")
local _frame_pong_key = _sbyteFunc("3")
local _frame_message_key = _sbyteFunc("4")
local _frame_upgrade_key = _sbyteFunc("5")
local _frame_noop_key = _sbyteFunc("6")

local _binary_message_key = 4

local _type_min = _sbyteFunc("0")
local _type_connect = _sbyteFunc("0")
local _type_disconnect = _sbyteFunc("1")
local _type_event = _sbyteFunc("2")
local _type_ack = _sbyteFunc("3")
local _type_error = _sbyteFunc("4")
local _type_binary_event = _sbyteFunc("5")
local _type_binary_ack = _sbyteFunc("6")
local _type_max = _sbyteFunc("6")
local _type_undetermined = _sbyteFunc("16") --undetermined mask bit
-------------------------------------------------------------------------

SocketIOCallbackType = 
{
    _open_Type = 1,
    _msg_Type = 2,
    _binary_Msg_Type = 3,
}

local _callbackOpenType = SocketIOCallbackType._open_Type
local _callbackMsgType = SocketIOCallbackType._msg_Type
local _callbackBinaryMsgType = SocketIOCallbackType._binary_Msg_Type

function socketIO:ctor(url)
    self.objWebSocket = nil
    
    self.callBackFuncs = {}

    self.iBinaryPendingBuffers = 0
    self.szBinaryEventName = nil

    -- æŸ¥æ‰¾event Name å’Œpb Name çš„å¯¹åº”å…³ç³»ï¼Œå¯ä»¥æ?¯functionæˆ–table, å‚æ•°è¿”å›å¦‚åŒ__index
    self.__pbNameMapping  = nil
    
    self.defaultSendTextFunc = nil
    self.defaultSendBinaryFunc = nil
end

    -- å°†WebSocketå¯¹è±¡æ³¨å†Œç»™socketIOï¼Œè¿™æ ·å½“WebSocketæ¥æ”¶åˆ°Msgæ¶ˆæ¯(cc.WEBSOCKET_MESSAGE)åå°†è½¬å‘ç»™socketIO
    -- å½“å‘é€msgæ—¶ï¼Œé»?è®¤çš„æƒ…å†µ socketIOä¼šé€šè¿‡æ­¤WebSocketå¯¹è±¡å‘é€
function socketIO:registerToWebSocket(objWebSocket)
    self.objWebSocket = objWebSocket
   
    objWebSocket:registerScriptHandler( function(strBuff) 
        _onWebSocketMsgHandler(self,strBuff)
    end ,cc.WEBSOCKET_MESSAGE)
end

    -- æŒ‰ç…§socketioåè®®ï¼Œæ³¨å†Œç»™ä½¿ç”¨è€…æ•°æ®æ¥æ”¶çš„callbackå‡½æ•°
    -- ç›®å‰æ ¹æ®éœ€æ±‚ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸‰ç§callback: 1.frame_open,2.textMsg,3.binary_Msg
    -- frame_open: ä¸»è¦ä¸ºäº†å›è°ƒsetPingã€‚ iType = SocketIOCallbackType._msg_Type, func = function(buff:string,offset:int) offset = 1
    -- textMsg:    æ¥æ”¶åˆ°æ–‡æœ¬ä¿¡æ¯ã€‚iType = SocketIOCallbackType._msg_Type, å?å‚æœ‰1ä¸ª(å¯é€‰)ã€‚è¡¨ç¤ºå†…å®¹æ?¯å¦ç”¨json,é»?è®¤æ?¯trueã€‚ 
    --      json: func = function(event:string,jsonTable) 
    --      éjson: func = function(buff:string,offset:int)   ï¼ˆç›®å‰æ²¡ç”¨ï¼Œæœªå®ç°ï¼‰
    -- BinaryMsg:  æ¥æ”¶åˆ°äºŒè¿›åˆ¶ä¿¡æ¯ã€‚iType = SocketIOCallbackType._binary_Msg_Typeï¼Œå?å‚æœ‰1ä¸ª(å¯é€‰)ã€‚è¡¨ç¤ºå†…å®¹æ?¯å¦ç”¨pb,é»?è®¤æ?¯trueã€‚
    --      pb:   func = function(event:string,pbTable)          
    --      épb: func = function(buff:äºŒè¿›åˆ¶ string,offset=int)
    -- ä¸ºä»€ä¹ˆè¦è®¾å®šä¸ºbuff:string + offset:int è¿™ç§å½¢å¼ï¼Ÿ string.subä¸å¥½å—ï¼Ÿ è¿™ä¹ˆåšæ?¯ä¸ºäº†å‡å°‘string.subäº§ç”Ÿçš„é¢å¤–gcã€‚
function socketIO:registerFun(iType,func, ...)
    local arg = {...}
    if iType == _callbackOpenType then
        self.callBackFuncs[iType] = func
    elseif iType == _callbackMsgType then
        local isJsonMsg = true
        if arg ~= nil and (#arg)>1 then
            isJsonMsg = arg[1]
        end
        self.callBackFuncs[iType] = {func,isJsonMsg}
    elseif iType == _callbackBinaryMsgType then
        local isPBMsg = true
        if arg ~= nil and (#arg)>1 then
            isPBMsg = arg[1]
        end
        self.callBackFuncs[iType] = {func,isPBMsg}
    end
end



function socketIO:isBinaryOver()
    if self.iBinaryPendingBuffers>0 then
        return false
    else
        return true
    end
end



function socketIO:PraseMsg(strBuff,iStart)
    --
    if strBuff ~= nil then

        local onMsgFunc = nil
        local isJsonMsg = true
        if self.callBackFuncs[_callbackMsgType] ~= nil then
            onMsgFunc = self.callBackFuncs[_callbackMsgType][1]
            isJsonMsg = self.callBackFuncs[_callbackMsgType][2]
        end

        if isJsonMsg then
            local jsonData = json.decode(strBuff,iStart)
            if onMsgFunc ~= nil and (#jsonData)>1 then
                -- print("socketIO:PraseMsg ".. tostring(jsonData[1]) .. " " .. tostring(jsonData[2]))
                onMsgFunc(jsonData[1],jsonData[2])
            end
        end
    end
end

function socketIO:PraseBinaryMsg(iPendingCount,tHead)
    self.iBinaryPendingBuffers = iPendingCount
    self.iBinaryRecvBuffers = 0
    local szBinaryEventName = tHead[1]
    if type(szBinaryEventName) ~= "string" then
        szBinaryEventName = nil
        for k,v in pairs(tHead) do
            if type(v) == "string" then
                szBinaryEventName = v
            end
        end
    end

    if szBinaryEventName == nil then
        print("Binary EventName is nil socketIO:SetBinaryHead") 
    end
    self.szBinaryEventName = szBinaryEventName

   -- print("................PraseBinaryMsg"..":::"..self.szBinaryEventName..":::"..self.iBinaryPendingBuffers)

end

function socketIO:putBinaryBuffer(strBuff,ioffset)
    if self.iBinaryPendingBuffers>0 then
        local onMsgFunc = nil
        local isPBMsg = true
        
        if self.callBackFuncs[_callbackBinaryMsgType] ~= nil then
            onMsgFunc = self.callBackFuncs[_callbackBinaryMsgType][1]
            isJsonMsg = self.callBackFuncs[_callbackBinaryMsgType][2]
        end

        --
        local iLen = string.len(strBuff)
       
        if onMsgFunc ~= nil then
            if isPBMsg then
                local szPBName = nil
                if self.__pbNameMapping ~= nil then
                    local szType = type(self.__pbNameMapping)
                    if szType == "table" then
                        szPBName = self.__pbNameMapping[self.szBinaryEventName]
                    elseif szType == "function" then
                        szPBName = self.__pbNameMapping(self.szBinaryEventName)
                    end
                end
                
                if szPBName == nil then
                    szPBName = self.szBinaryEventName
                end
                local tPb = protobuf.decode(szPBName, strBuff,ioffset)
                onMsgFunc(self.szBinaryEventName,tPb)
            end
        end

        self.iBinaryPendingBuffers = self.iBinaryPendingBuffers-1
    else
        --assert

    end
end

    -- å‘é€æ–‡æœ¬æ•°æ®
    -- szEvent string
    -- inforData å¦‚æœæ?¯jsonå¯¹è±¡,è¯·ä¼ table,å¦‚æœæ?¯å­—ç¬¦ä¸²(åŒ…æ‹¬jsonå­—ç¬¦ä¸²)è¯·ä¼ string
    -- sendFunå‘é€çš„æ–¹æ³•,å¯ä»¥ä¸ä¼ ,å°†ä½¿ç”¨å·²ç»æ³¨å†Œçš„websocketåšé»?è®¤å‘é€ï¼Œå‡½æ•°å½¢å¼: funtion(strSend) strSendä¸ºstring

--local _textTab = {string.char(_frame_message_key),string.char(_type_event),"[", "\"", "", "\"", ",","","]" }
local _textTab = {string.char(_frame_message_key),string.char(_type_event),""}
function socketIO:sendTextData(szEvent,inforData,sendFun)
   
    --_textTab[5] = szEvent
    --_textTab[8] = inforData
    if sendFun == nil then
        sendFun = self:GetDefSendTextFunc()
    end

    _textTab[3] = json.encode({szEvent,inforData})
    local szSend = _tconcatFunc(_textTab) 
    _textTab[3] = ""
    sendFun(szSend)
end

    
    -- å‘é€äºŒè¿›åˆ¶æ•°æ®
    -- szEvent string
    -- strBuffData äºŒè¿›åˆ¶string
    -- sendTextFun å‘é€æ–‡æœ¬æ®µçš„æ–¹æ³•,å¯ä»¥ä¸ä¼ ,å°†ä½¿ç”¨é»?è®¤å‘é€çš„æ–¹æ³•ï¼Œè¦æ?¯ä½¿ç”¨ï¼Œå‡½æ•°å½¢å¼: funtion(strSend) strSendä¸ºstring
    -- sendTextFun å‘é€äºŒè¿›åˆ¶æ®µçš„æ–¹æ³•,å¯ä»¥ä¸ä¼ ,å°†ä½¿ç”¨é»?è®¤å‘é€çš„æ–¹æ³•ï¼Œè¦æ?¯ä½¿ç”¨ï¼Œå‡½æ•°å½¢å¼: funtion(strSend) strSendä¸ºäºŒè¿›åˆ¶string 
local _oneBinaryHead1 = _tconcatFunc({string.char(_frame_message_key),string.char(_type_binary_event),"1-"})
function socketIO:sendOneBinaryData(szEvent,strBuffData,sendTextFun,sendBinaryFun)
    if sendTextFun == nil then
        sendTextFun = self:GetDefSendTextFunc()
    end
    
    if sendBinaryFun == nil then
        sendBinaryFun = self:GetDefSendBinaryFunc()
    end

    local szHead = _tconcatFunc({_oneBinaryHead1,json.encode({szEvent,{_placeholder = true,num =0} }) })
    sendTextFun(szHead)
    local strBinarybuff = nil
    
    if strBuffData == nil then
        strBinarybuff = string.char(_binary_message_key)
    elseif type(strBuffData) == "string" then
        strBinarybuff =_tconcatFunc( {string.char(_binary_message_key),strBuffData})
    -- table pb
    elseif type(strBuffData) == "table" then
        local szPBName = nil
        if self.__pbNameMapping ~= nil then
            local szType = type(self.__pbNameMapping)
            if szType == "table" then
                szPBName = self.__pbNameMapping[szEvent]
            elseif szType == "function" then
                szPBName = self.__pbNameMapping(szEvent)
            end
        end
        if szPBName == nil then
            szPBName = szEvent
        end
        local strbuff = protobuf.encode(szPBName, strBuffData)
        strBinarybuff =_tconcatFunc( {string.char(_binary_message_key),strbuff})
        
    else
        strBinarybuff = string.char(_binary_message_key)
    end
    sendBinaryFun(strBinarybuff)
end

function socketIO:GetDefSendTextFunc()
    if self.defaultSendTextFunc == nil then
        local objWebSocket = self.objWebSocket
        self.defaultSendTextFunc = function(sendStr)
            if objWebSocket ~= nil and objWebSocket:getReadyState() == cc.WEBSOCKET_STATE_OPEN then
                objWebSocket:setDataType(WS_DATA_FORMAT_TEXT)
                objWebSocket:sendString(sendStr)
            else
                if objWebSocket ~= nil then
                    print(':error webSocket state = ', objWebSocket:getReadyState())
                else
                    print(':error webSocket is nil')
                end
            end
        end
    end

    return self.defaultSendTextFunc
end

function socketIO:GetDefSendBinaryFunc()
    if self.defaultSendBinaryFunc == nil then
        local objWebSocket = self.objWebSocket
        --self.defaultSendBinaryFunc = self:GetDefSendTextFunc()
        self.defaultSendBinaryFunc = function(sendStr)
            if objWebSocket ~= nil and objWebSocket:getReadyState() == cc.WEBSOCKET_STATE_OPEN then
                objWebSocket:setDataType(WS_DATA_FORMAT_BINARY)
                objWebSocket:sendString(sendStr)
            else
                if objWebSocket ~= nil then
                    print(':error webSocket state = ', objWebSocket:getReadyState())
                else
                    print(':error webSocket is nil')
                end
            end
        end
    end

    return self.defaultSendBinaryFunc
end



_onWebSocketMsgHandler = function(objSocketIO,strBuff)
    
    --[[
    local szType = type(strBuff)
    if szType == "table" then
        --print("------------------------------------"..szType)
        dump(strBuff, 'MsgID_PD_PutDown_Coin')
    end
    ]]--
    if objSocketIO ~= nil and type(strBuff) == "string" then
        --prase
        local frameKey = _sbyteFunc(strBuff,1)
        if frameKey == _frame_open_key then
            local openFunc = objSocketIO.callBackFuncs[_callbackOpenType]
            if openFunc ~= nil  then
                openFunc(strBuff,1)
            end

        elseif frameKey == _frame_close_key then

        elseif frameKey == _frame_ping_key then

        elseif frameKey == _frame_pong_key then

        elseif frameKey == _frame_message_key then
            -- msg
            local typeKey = _sbyteFunc(strBuff,2)
            if typeKey == _type_event then
                objSocketIO:PraseMsg(strBuff,3)
            elseif typeKey == _type_binary_event then
                -- find "-" cal conut
               
                local iPosEnd = string.find(strBuff,"-",3)
                local szCount = _ssubFunc(strBuff,3,iPosEnd-1)
                local iCount = tonumber(szCount)
                local szJsonHead = _ssubFunc(strBuff,iPosEnd+1,-1)
                local tJsonHead = json.decode(szJsonHead)           
                
                objSocketIO:PraseBinaryMsg(iCount,tJsonHead)
            
            end

        elseif frameKey == _frame_upgrade_key then
        
        elseif frameKey == _frame_noop_key then

        elseif frameKey == _binary_message_key then
            objSocketIO:putBinaryBuffer(strBuff,2)
        else

        end
    end
end




return socketIO
