--如果游戏想自己实现重连,网络出错,超时等逻辑,可以require此文件,此文件只做websock代理的中转。
local _wsManager = {} --inject websocket manager into _wsManager

--websocket states
WS_READYSTATE_CONNECTING = 0
WS_READYSTATE_OPEN = 1
WS_READYSTATE_CLOSING = 2
WS_READYSTATE_CLOSED = 3
WS_READYSTATE_ERROR = 4

WS_PROXY_COMMAND_OPEN = '1'
WS_PROXY_COMMAND_CLOSE = '3'
WS_PROXY_COMMAND_ERROR = '4'
WS_PROXY_COMMAND_MSG = '2'


APP_NET_READY = 100000
APP_NET_ERROR = 100001

--WS_DATA_FORMAT_TEXT = 0
--WS_DATA_FORMAT_BINARY = 1

--local websockproxy = {}
local websockproxy = class('WebSocket')

local TAG = '[WebSocketProxy_No_Auto_Reconnect]'

local function splitString(s, p)
    local subStrings= {}
    string.gsub(
        s ,
        '[^'..p..']+' ,
        function(w)
            table.insert(subStrings, w) 
        end
    )
    return subStrings
end

local function trim(s)
  return string.match(s,'^()%s*$') and '' or string.match(s,'^%s*(.*%S)')
end

local function parseProtocol(url)
    local subStrings = splitString(url,':')
    if #subStrings ~= 2 then
        return 'ws'
    else 
        return subStrings[1] 
    end
end

function websockproxy:ctor(url)
    local ws = {}
    setmetatable(ws, self)  
    self.__index = self

    ws.url = url
    ws.protocol = parseProtocol(url)
    ws.readystate = WS_READYSTATE_CONNECTING
    ws.event_handle = {}
    ws.cid = cc._getWebSocketProxyConnectID()
    
    ws.proxy_send_text_header = '[2,'..tostring(ws.cid)..',1]'
    ws.proxy_send_binary_header = '[2,'..tostring(ws.cid)..',2]'

    ws.dataType = WS_DATA_FORMAT_TEXT
    ws.proxy_send_header = ws.proxy_send_text_header
    _wsManager[ws.cid] = ws    
end

function websockproxy:create(url)
    local ws = {}
    setmetatable(ws, self)  
    self.__index = self    

    ws.url = url
    ws.protocol = parseProtocol(url)
    ws.readystate = WS_READYSTATE_CONNECTING
    ws.event_handle = {}
    ws.cid = cc._getWebSocketProxyConnectID()

    ws.proxy_send_text_header = '[2,'..tostring(ws.cid)..',1]'
    ws.proxy_send_binary_header = '[2,'..tostring(ws.cid)..',2]'

    ws.dataType = WS_DATA_FORMAT_TEXT
    ws.proxy_send_header = ws.proxy_send_text_header
    _wsManager[ws.cid] = ws
    ws:connect()

    return ws
end

function websockproxy:setDataType(dataType)
    print('websockproxy:setDataType ,datatype is '..tostring(dataType))
    self.dataType = dataType
    if self.dataType == WS_DATA_FORMAT_BINARY then
        self.proxy_send_header = self.proxy_send_binary_header
    else
        self.proxy_send_header = self.proxy_send_text_header
    end
end

function websockproxy:connect()
    print('websocket is conecting ,url='..self.url)
    cc.NativeBridge:getInstance():gameSendData(
        '' ,
        '[1,'..tostring(self.cid)..',"'..self.url..'"]' ,
        ''
    )
end

function websockproxy:setNotAutoReConnect(notAutoReconnect)

end

function websockproxy:setAutoReconnect(autoReconnect)

end

function websockproxy:getReadyState()
    return self.readystate
end

function websockproxy:close()
    if _wsManager[self.cid] == nil then
        return 
    end

    cc.NativeBridge:getInstance():gameSendData(
        '' ,
        '[3,'..tostring(self.cid)..']' ,
        ''
    )
    _wsManager[self.cid] = nil

    self:onSocketState(cc.WEBSOCKET_CLOSE)
end

function websockproxy:sendString(data)    
    if WS_READYSTATE_OPEN == self.readystate then
        cc.NativeBridge:getInstance():gameSendData(
            '' ,
            self.proxy_send_header ,
            data
        )
    else
        print(TAG..'error websock:sendString connectionID='..self.cid..',readystate='..self.readystate..',data='..data);
    end
end


function websockproxy:registerScriptHandler(func,evt)
    --print(string.format('%sregisterScriptHandler evt=%d,func=%s',TAG,evt,func))
    self.event_handle[evt] = func
end

function websockproxy:unregisterScriptHandler(evt)
    print(string.format('%unregisterScriptHandler evt=%d',TAG,evt))
    self.event_handle[evt] = nil    
end

function websockproxy:onSocketState(evt)
    print(TAG..'websockproxy:onSocketState connectionID='..self.cid..',evt='..evt)
    if evt == cc.WEBSOCKET_OPEN then
        self.readystate = WS_READYSTATE_OPEN
        print(TAG..'websockproxy:onSocketState ，websocket opened ,connectionID='..self.cid)
    elseif evt == cc.WEBSOCKET_CLOSE then
        self.event_handle={}        
        _wsManager[self.cid] = nil        
        self.readystate = WS_READYSTATE_CLOSED
        print(TAG..'websockproxy:onSocketState ，websocket closed ,connectionID='..self.cid)
    elseif evt == cc.WEBSOCKET_ERROR then
        self.readystate = WS_READYSTATE_ERROR        
        print(TAG..'websockproxy:onSocketState ，websocket error ,connectionID='..self.cid)
    end

    local func = self.event_handle[evt]
    if func ~= nil and type(func)=='function' then
        func('')       
    end
end

local function parseHeader(header)
    if string.len(header) < 2 then
        print(TAG..'invalid header ,header length is less than 2 .header='..header)
        return nil
    end

    local headerTable = splitString(string.sub(header ,2 ,string.len(header)-1) ,',')    
    if #headerTable < 2 or #headerTable > 3 then
        print(TAG..'invalid header ,format error ,header='..header)
        return nil        
    elseif #headerTable > 2 then
        headerTable.opcode = trim(headerTable[3]) --tonumber(headerTable[3])
    end

    headerTable.command = trim(headerTable[1]) --tonumber(headerTable[1])
    headerTable.connectionID = tonumber(headerTable[2])

    return headerTable
end

function appReceiveData(context ,header ,body)
    --print(TAG..'appReceiveData ,header='..header..',body='..body)
    local headerTable = parseHeader(header)
    if headerTable == nil then
        print(TAG..'appReceiveData ,invalid header ,header format error'..header)
        return
    end

    local ws = _wsManager[headerTable.connectionID]
    if ws == nil then
        print(TAG..'appReceiveData ,connection id is closed or invalid,connectionId='..headerTable.connectionID)
        return
    end    
    
    if headerTable.command == WS_PROXY_COMMAND_MSG then
        local msgHandler = ws.event_handle[cc.WEBSOCKET_MESSAGE]
        if msgHandler ~= nil then
            --print(TAG..'appReceiveData onGameMessage ,msg='..body)
            msgHandler(body)
        else
            print(TAG..'appReceiveData ，receive message but no handler,header='..header)
        end
    elseif headerTable.command == WS_PROXY_COMMAND_CLOSE then
        ws:onSocketState(cc.WEBSOCKET_CLOSE)        
    elseif headerTable.command == WS_PROXY_COMMAND_OPEN then
        ws:onSocketState(cc.WEBSOCKET_OPEN)
    elseif headerTable.command == WS_PROXY_COMMAND_ERROR then
        ws:onSocketState(cc.WEBSOCKET_ERROR)
    end    
end

function appChannelStateChanged(context ,seqid ,state)
    local state = string.byte(state)
    if state == cc.APP_NET_CHANNEL_INIT 
        or state == cc.APP_NET_CHANNEL_CONNECTING 
        or state == cc.APP_NET_CHANNEL_RECONNECTING 
        or state == cc.APP_NET_CHANNEL_CONNECTED then
        print(TAG..'appchannel state changed for init or connecting/reconnecting')
    elseif state == cc.APP_NET_CHANNEL_READY then
        print(TAG..'appchannel state changed ,state = APP_NET_CHANNEL_READY')
        local cidNum = 0
        local cidTable = {}          
        for _ ,ws in pairs(_wsManager) do
            if ws ~=nil and type(ws) ~= 'number' then
                cidNum = cidNum + 1
                cidTable[cidNum] = ws.cid
            end            
        end
        for _, cid in ipairs(cidTable) do
            if _wsManager[cid] ~= nil then
                _wsManager[cid]:onSocketState(APP_NET_READY)
            end
        end        
    elseif state == cc.APP_NET_CHANNEL_ERROR or state == cc.APP_NET_CHANNEL_LINKERROR then 
        print(TAG..'appchannel state changed ,state = APP_NET_CHANNEL_ERROR')
        local cidNum = 0
        local cidTable = {}          
        for _ ,ws in pairs(_wsManager) do
            if ws ~=nil and type(ws) ~= 'number' then
                cidNum = cidNum + 1
                cidTable[cidNum] = ws.cid
            end            
        end
        for _, cid in ipairs(cidTable) do
            if _wsManager[cid] ~= nil then
                _wsManager[cid]:onSocketState(APP_NET_ERROR)
            end
        end 
    end    
end

function closeAllWebsocketConnections()
    print(TAG..'closeAllWebsocketConnections start')
    for _ ,ws in pairs(_wsManager) do
        if ws ~=nil and type(ws)~= 'number' then
            cc.NativeBridge:getInstance():gameSendData(
                '' ,
                '[3,'..tostring(ws.cid)..']' ,
                ''
            )
            _wsManager[ws.cid] = nil
        end
    end
    print(TAG..'closeAllWebsocketConnections end')
end
return websockproxy
