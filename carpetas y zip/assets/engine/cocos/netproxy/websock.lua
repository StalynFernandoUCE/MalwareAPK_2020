--websock auto reconnect
local _wsManager = {} --inject websocket manager into _wsManager

--websocket states
WS_READYSTATE_CONNECTING = 0
WS_READYSTATE_OPEN = 1
WS_READYSTATE_CLOSING = 2
WS_READYSTATE_CLOSED = 3
WS_READYSTATE_ERROR = 4

WS_PROXY_COMMAND_OPEN = '1'
WS_PROXY_COMMAND_CLOSE = '3'
WS_PROXY_COMMAND_ERROR = '4'
WS_PROXY_COMMAND_MSG = '2'

-- The following two global variables are defined in engine/cocos/network/NetworkConstants.lua
-- WS_DATA_FORMAT_TEXT = 0
-- WS_DATA_FORMAT_BINARY = 1
--

local websock = class('WebSocket')
local TIMEOUT_EVENT_ID =  2008
local WEBSOCKET_TIMEOUT = 10
local DELAY_CONNECT_TIME = 1
local CONNECT_MAX_COUNT = 10

local TAG = '[WebSocketProxy]'


local function splitString(s, p)
    local subStrings= {}
    string.gsub(
        s ,
        '[^'..p..']+' ,
        function(w)
            table.insert(subStrings, w) 
        end
    )
    return subStrings
end

local function trim(s)
  return string.match(s,'^()%s*$') and '' or string.match(s,'^%s*(.*%S)')
end

local function parseProtocol(url)
    local subStrings = splitString(url,':')
    if #subStrings ~= 2 then
        return 'ws'
    else 
        return subStrings[1] 
    end
end

function websock:ctor(url)
    local ws = {}
    setmetatable(ws, self)  
    self.__index = self

    ws.url = url
    ws.protocol = parseProtocol(url)
    ws.readystate = WS_READYSTATE_CONNECTING
    ws.event_handle = {}
    ws.cid = cc._getWebSocketProxyConnectID()
    ws.timeID = nil
    ws._delayReConnectSocketHandle = nil
    
    ws.proxy_send_text_header = '[2,'..tostring(ws.cid)..',1]'
    ws.proxy_send_binary_header = '[2,'..tostring(ws.cid)..',2]'

    ws.dataType = WS_DATA_FORMAT_TEXT
    ws.proxy_send_header = ws.proxy_send_text_header
    ws._connectCount = 0
    ws._autoReconnect = true
    _wsManager[ws.cid] = ws    
end

function websock:create(url)
    local ws = {}
    setmetatable(ws, self)  
    self.__index = self    

    ws.url = url
    ws.protocol = parseProtocol(url)
    ws.readystate = WS_READYSTATE_CONNECTING
    ws.event_handle = {}
    ws.cid = cc._getWebSocketProxyConnectID()
    
    ws.proxy_send_text_header = '[2,'..tostring(ws.cid)..',1]'
    ws.proxy_send_binary_header = '[2,'..tostring(ws.cid)..',2]'

    ws.dataType = WS_DATA_FORMAT_TEXT
    ws.proxy_send_header = ws.proxy_send_text_header
    ws._connectCount = 0
    ws._autoReconnect = true
    ws._delayReConnectSocketHandle = nil
    _wsManager[ws.cid] = ws
    ws:connect()

    return ws
end

function websock:setDataType(dataType)
    -- Don't print log here since setDataType may be invoked frequently.
    -- print('websock:setDataType ,datatype is '..tostring(dataType))
    self.dataType = dataType
    if self.dataType == WS_DATA_FORMAT_BINARY then
        self.proxy_send_header = self.proxy_send_binary_header
    else
        self.proxy_send_header = self.proxy_send_text_header
    end
end

function websock:_appConnect()
    if not self._autoReconnect then
        return
    end
    if self._delayReConnectSocketHandle ~= nil then
        cc.Director:getInstance():getScheduler():unscheduleScriptEntry(self._delayReConnectSocketHandle)
        self._delayReConnectSocketHandle = nil
    end
    self:connect()
end

function websock:_delayConnect()
    if not self._autoReconnect then
        return
    end
    if self._connectCount < CONNECT_MAX_COUNT then
        if self._delayReConnectSocketHandle == nil then
            self._delayReConnectSocketHandle = cc.Director:getInstance():getScheduler():scheduleScriptFunc(handler(self, self._delayReConnectSocket), DELAY_CONNECT_TIME, false)
        end
    end
end

function websock:_delayReConnectSocket(dt)
    if self._delayReConnectSocketHandle ~= nil then
        cc.Director:getInstance():getScheduler():unscheduleScriptEntry(self._delayReConnectSocketHandle)
        self._delayReConnectSocketHandle = nil
    end
    self._connectCount = self._connectCount + 1;
    self:connect()
end

function websock:connect()
    print('websocket is conecting ,url='..self.url)
    cc.NativeBridge:getInstance():gameSendData(
        '' ,
        '[1,'..tostring(self.cid)..',"'..self.url..'"]' ,
        ''
    )
    if not self._autoReconnect then
        return
    end
    if self.timeID ~= nil then
        if cc.Director:getInstance() ~= nil then
            cc.Director:getInstance():getScheduler():unscheduleScriptEntry(self.timeID)
        end
        self.timeID = nil --cancel timer
    end 
    self.timeID = cc.Director:getInstance():getScheduler():scheduleScriptFunc(
        handler(self, self._timeOutEvent),
        WEBSOCKET_TIMEOUT ,
        false
    )
end

function websock:_timeOutEvent()
    print(TAG..'_timeOutEvent')
    if self.timeID ~= nil then
        if cc.Director:getInstance() ~= nil then
            cc.Director:getInstance():getScheduler():unscheduleScriptEntry(self.timeID)
        end
        self.timeID = nil
    end
    self:onSocketState(cc.WEBSOCKET_ERROR)
end

function websock:setNotAutoReConnect(notAutoReconnect)
    self._autoReconnect = (not notAutoReconnect)
end

function websock:setAutoReconnect(autoReconnect)
    self._autoReconnect = autoReconnect
end

function websock:getReadyState()
    return self.readystate
end

function websock:close()
    if _wsManager[self.cid] == nil then
        return 
    end

    cc.NativeBridge:getInstance():gameSendData(
        '' ,
        '[3,'..tostring(self.cid)..']' ,
        ''
    )

    self:_cleanupTimer()
    _wsManager[self.cid] = nil

    self:onSocketState(cc.WEBSOCKET_CLOSE)
end

function websock:sendString(data)   
    if WS_READYSTATE_OPEN == self.readystate then
        cc.NativeBridge:getInstance():gameSendData(
            '' ,
            self.proxy_send_header ,
            data
        )
    else
        print(TAG..'error websock:sendString connectionID='..self.cid..',readystate='..self.readystate..',data='..data);
    end
end

function websock:_cleanupTimer()
    if self.timeID ~= nil then
        if cc.Director:getInstance() ~= nil then
            cc.Director:getInstance():getScheduler():unscheduleScriptEntry(self.timeID)
        end
        self.timeID = nil --cancel timer
    end 
    if self._delayReConnectSocketHandle ~= nil then
        cc.Director:getInstance():getScheduler():unscheduleScriptEntry(self._delayReConnectSocketHandle)
        self._delayReConnectSocketHandle = nil
    end
end

function websock:registerScriptHandler(func,evt)
    --print(string.format('%sregisterScriptHandler evt=%d,func=%s',TAG,evt,func))
    self.event_handle[evt] = func
end

function websock:unregisterScriptHandler(evt)
    print(string.format('%s,unregisterScriptHandler evt=%d',TAG,evt))
    self.event_handle[evt] = nil    
end

function websock:onSocketState(evt)
    print(TAG..'websock:onSocketState connectionID='..self.cid..',evt='..evt)
    if evt == cc.WEBSOCKET_OPEN then
        self._connectCount = 0
        self.readystate = WS_READYSTATE_OPEN
        print(TAG..'websock:onSocketState ，websocket opened ,connectionID='..self.cid)
    end

    local func = self.event_handle[evt]
    if func ~= nil and type(func)=='function' then
        func('')       
    end

    self:_cleanupTimer()
    if evt == cc.WEBSOCKET_CLOSE then
        self.event_handle={}        
        _wsManager[self.cid] = nil        
        self.readystate = WS_READYSTATE_CLOSED
        print(TAG..'websock:onSocketState ，websocket closed ,connectionID='..self.cid)
    elseif evt == cc.WEBSOCKET_ERROR then
        self.readystate = WS_READYSTATE_ERROR        
        print(TAG..'websock:onSocketState ，websocket error ,connectionID='..self.cid)
        self:_delayConnect()
    end
end

local function parseHeader(header)
    if string.len(header) < 2 then
        print(TAG..'invalid header ,header length is less than 2 .header='..header)
        return nil
    end

    local headerTable = splitString(string.sub(header ,2 ,string.len(header)-1) ,',')    
    if #headerTable < 2 or #headerTable > 3 then
        print(TAG..'invalid header ,format error ,header='..header)
        return nil        
    elseif #headerTable > 2 then
        headerTable.opcode = trim(headerTable[3]) --tonumber(headerTable[3])
    end

    headerTable.command = trim(headerTable[1]) --tonumber(headerTable[1])
    headerTable.connectionID = tonumber(headerTable[2])

    return headerTable
end

function appReceiveData(context ,header ,body)
    --print(TAG..'appReceiveData ,header='..header..',body='..body)
    local headerTable = parseHeader(header)
    if headerTable == nil then
        print(TAG..'appReceiveData ,invalid header ,header format error'..header)
        return
    end

    local ws = _wsManager[headerTable.connectionID]
    if ws == nil then
        print(TAG..'appReceiveData ,connection id is closed or invalid,connectionId='..headerTable.connectionID)
        return
    end    
    
    if headerTable.command == WS_PROXY_COMMAND_MSG then
        ws._connectCount = 0
        local msgHandler = ws.event_handle[cc.WEBSOCKET_MESSAGE]
        if msgHandler ~= nil then
            --print(TAG..'appReceiveData onGameMessage ,msg='..body)
            msgHandler(body)
        else
            print(TAG..'appReceiveData ，receive message but no handler,header='..header)
        end
    elseif headerTable.command == WS_PROXY_COMMAND_CLOSE then       
        ws:onSocketState(cc.WEBSOCKET_CLOSE)        
    elseif headerTable.command == WS_PROXY_COMMAND_OPEN then          
        ws:onSocketState(cc.WEBSOCKET_OPEN)
    elseif headerTable.command == WS_PROXY_COMMAND_ERROR then
        ws:onSocketState(cc.WEBSOCKET_ERROR)
    end    
end

function appChannelStateChanged(context ,seqid ,state)
    local state = string.byte(state)
    if state == cc.APP_NET_CHANNEL_INIT 
        or state == cc.APP_NET_CHANNEL_CONNECTING 
        or state == cc.APP_NET_CHANNEL_RECONNECTING 
        or state == cc.APP_NET_CHANNEL_CONNECTED then
        print(TAG..'appchannel state changed for init or connecting/reconnecting')
        for _ ,ws in pairs(_wsManager) do
            if ws ~=nil and type(ws) ~= 'number' then
                if ws._cleanupTimer ~= nil then
                    ws:_cleanupTimer()
                end
                ws.readystate = WS_READYSTATE_CONNECTING
            end            
        end
    elseif state == cc.APP_NET_CHANNEL_READY then   
        local cidNum = 0
        local cidTable = {}          
        for _ ,ws in pairs(_wsManager) do
            if ws ~=nil and type(ws) ~= 'number' then
                cidNum = cidNum + 1
                cidTable[cidNum] = ws.cid
            end            
        end
        for _, cid in ipairs(cidTable) do
            if _wsManager[cid] ~= nil then
                _wsManager[cid]:_appConnect()
            end
        end            
        print(TAG..'appchannel state changed ,state = APP_NET_CHANNEL_READY')
    elseif state == cc.APP_NET_CHANNEL_ERROR or state == cc.APP_NET_CHANNEL_LINKERROR then        
        local cidNum = 0
        local cidTable = {}          
        for _ ,ws in pairs(_wsManager) do
            if ws ~=nil and type(ws) ~= 'number' then
                cidNum = cidNum + 1
                cidTable[cidNum] = ws.cid
            end            
        end   
        for _, cid in ipairs(cidTable) do
            if _wsManager[cid] ~= nil then
            _wsManager[cid]._connectCount = 0
                _wsManager[cid]:onSocketState(cc.WEBSOCKET_ERROR) 
            end
        end  
        print(TAG..'appchannel state changed ,state = WEBSOCKET_ERROR')
    end    
end

function closeAllWebsocketConnections()
    print(TAG..'closeAllWebsocketConnections start')
    for _ ,ws in pairs(_wsManager) do
        if ws ~=nil and type(ws)~= 'number' then
            cc.NativeBridge:getInstance():gameSendData(
                '' ,
                '[3,'..tostring(ws.cid)..']' ,
                ''
            )

            if ws._cleanupTimer ~= nil then
                ws:_cleanupTimer()
            end
            _wsManager[ws.cid] = nil
        end            
    end
    print(TAG..'closeAllWebsocketConnections end')
end

return websock
