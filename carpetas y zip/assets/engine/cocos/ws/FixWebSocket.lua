local TAG = '[FixWebSocket]'
local _fixWebSocket = class('FixWebSocket')
function _fixWebSocket:create(url)
    local ws = {}
    setmetatable(ws, self)  
    self.__index = self
    ws.url = url
    ws.loadUrl = url
    ws.protocol = ""
    ws.networkType = cc.NET_INVALID;
    ws._autoReconnect = true
    print(TAG.." create = "..ws.loadUrl)
    ws.webSocket = cc.WebSocketBase:create(ws.loadUrl)
    return ws
end

function _fixWebSocket:setNotAutoReConnect(notAutoReconnect)
    self._autoReconnect = (not notAutoReconnect)
end

function _fixWebSocket:setAutoReconnect(autoReconnect)
    self._autoReconnect = autoReconnect
end

function _fixWebSocket:reConnectSocket(isError)
    if self.isConnecting then
        return
    end
    if self.delayReConnectSocketHandle then
        cc.Director:getInstance():getScheduler():unscheduleScriptEntry(self.delayReConnectSocketHandle)
        self.delayReConnectSocketHandle = nil
    end
    if self.delayDispatchCloseEventHandle then
        cc.Director:getInstance():getScheduler():unscheduleScriptEntry(self.delayDispatchCloseEventHandle)
        self.delayDispatchCloseEventHandle = nil
    end
    self.webSocket:unregisterScriptHandler(cc.WEBSOCKET_OPEN)
    self.webSocket:unregisterScriptHandler(cc.WEBSOCKET_MESSAGE)
    self.webSocket:unregisterScriptHandler(cc.WEBSOCKET_CLOSE)
    self.webSocket:unregisterScriptHandler(cc.WEBSOCKET_ERROR)
    if isError then
        local curReadyState = self.webSocket:getReadyState()
        if (curReadyState == cc.WEBSOCKET_STATE_OPEN) or (curReadyState == cc.WEBSOCKET_STATE_CONNECTING) then
            self.webSocket:close()
        end
    end
    self.isConnecting = true
    self.delayReConnectSocketHandle = cc.Director:getInstance():getScheduler():scheduleScriptFunc(handler(self, self.delayReConnectSocket), 1.0, false)
end
function _fixWebSocket:delayReConnectSocket(dt)
    if self.delayReConnectSocketHandle then
        cc.Director:getInstance():getScheduler():unscheduleScriptEntry(self.delayReConnectSocketHandle)
        self.delayReConnectSocketHandle = nil
    end
    print(TAG.." delayReConnectSocket create = "..self.loadUrl)
    self.webSocket = cc.WebSocketBase:create(self.loadUrl)
    if self.curDataType ~= nil then
        self.webSocket:setDataType(self.curDataType)
    end
    if self.onWebsocketOpenHandler ~= nil then
        self.webSocket:registerScriptHandler(handler(self, self.onWebsocketOpen), cc.WEBSOCKET_OPEN)
    end
    if self.onWebsocketMessageHandler ~= nil then
        self.webSocket:registerScriptHandler(handler(self, self.onWebsocketMessage), cc.WEBSOCKET_MESSAGE)
    end
    if self.onWebsocketCloseHandler ~= nil then
        self.webSocket:registerScriptHandler(handler(self, self.onWebsocketClose), cc.WEBSOCKET_CLOSE)
    end
    if self.onWebsocketErrorHandler ~= nil then
        self.webSocket:registerScriptHandler(handler(self, self.onWebsocketError), cc.WEBSOCKET_ERROR)
    end
end
function _fixWebSocket:getReadyState()
    if not self.webSocket then
        --print("_fixWebSocket:getReadyState self.webSocket = nil wsEventId = "..wsEventId)
        return
    end
    return self.webSocket:getReadyState()
end

function _fixWebSocket:close()
    if self.delayReConnectSocketHandle then
        cc.Director:getInstance():getScheduler():unscheduleScriptEntry(self.delayReConnectSocketHandle)
        self.delayReConnectSocketHandle = nil
    end
    if self.delayDispatchCloseEventHandle then
        cc.Director:getInstance():getScheduler():unscheduleScriptEntry(self.delayDispatchCloseEventHandle)
        self.delayDispatchCloseEventHandle = nil
    end
    self.closeMySelf = true
    self.webSocket:close()
end

function _fixWebSocket:sendString(data)
    if self.webSocket ~= nil then
        self.webSocket:sendString(data)
    else
        print(TAG.." sendString self.webSocket = nil"..data);
    end
end

function _fixWebSocket:setDataType(dataType)
    if self.webSocket ~= nil then
        self.webSocket:setDataType(dataType)
        self.curDataType = dataType
    else
        print(TAG.." setDataType self.webSocket = nil"..dataType);
    end
end

function _fixWebSocket:registerScriptHandler(cbHandler, wsEventId)
    if not self.webSocket then
        --print("_fixWebSocket:registerScriptHandler self.webSocket = nil wsEventId = "..wsEventId)
        return
    end
    if wsEventId == cc.WEBSOCKET_OPEN then
        self.onWebsocketOpenHandler = cbHandler
        self.webSocket:registerScriptHandler(handler(self, self.onWebsocketOpen), wsEventId)
    elseif wsEventId == cc.WEBSOCKET_MESSAGE then
        self.onWebsocketMessageHandler = cbHandler
        self.webSocket:registerScriptHandler(handler(self, self.onWebsocketMessage), wsEventId)
    elseif wsEventId == cc.WEBSOCKET_CLOSE then
        self.onWebsocketCloseHandler = cbHandler
        self.webSocket:registerScriptHandler(handler(self, self.onWebsocketClose), wsEventId)
    elseif wsEventId == cc.WEBSOCKET_ERROR then
        self.onWebsocketErrorHandler = cbHandler
        self.webSocket:registerScriptHandler(handler(self, self.onWebsocketError), wsEventId)
    end
end

function _fixWebSocket:onWebsocketOpen(data)
    self.isConnecting = nil
    self.url = self.webSocket.url
    print(TAG.." onWebsocketOpen = "..self.url)
    self.protocol = self.webSocket.protocol
    if cc.Director:getInstance():getOpenGLView() ~= nil and cc.Director:getInstance():getOpenGLView().getNetworkType ~= nil then
        self.networkType = cc.Director:getInstance():getOpenGLView():getNetworkType()
    end
    if self.onWebsocketOpenHandler ~= nil then
        self.onWebsocketOpenHandler(data)
    end
end

function _fixWebSocket:onWebsocketMessage(data)
    self.isConnecting = nil
    if self.onWebsocketMessageHandler ~= nil then
        self.onWebsocketMessageHandler(data)
    end
end

function _fixWebSocket:onWebsocketClose(data)
    self.isConnecting = nil
    self.closeData = data
    if self.closeMySelf or (not self._autoReconnect) then
        if self.onWebsocketCloseHandler ~= nil then
            self.onWebsocketCloseHandler(data)
        end
    else
        if self.delayDispatchCloseEventHandle then
            cc.Director:getInstance():getScheduler():unscheduleScriptEntry(self.delayDispatchCloseEventHandle)
            self.delayDispatchCloseEventHandle = nil
        end
        self.delayDispatchCloseEventHandle = cc.Director:getInstance():getScheduler():scheduleScriptFunc(handler(self, self.delayDispatchCloseEvent), 0.1, false)
    end
end

function _fixWebSocket:delayDispatchCloseEvent(dt)
    if self.delayDispatchCloseEventHandle then
        cc.Director:getInstance():getScheduler():unscheduleScriptEntry(self.delayDispatchCloseEventHandle)
        self.delayDispatchCloseEventHandle = nil
    end
    local newNetworkType = cc.NET_INVALID
    if cc.Director:getInstance():getOpenGLView() ~= nil and cc.Director:getInstance():getOpenGLView().getNetworkType ~= nil then
        newNetworkType = cc.Director:getInstance():getOpenGLView():getNetworkType()
    end
    print(TAG.."=======onWebsocketClose======newNetworkType="..newNetworkType.."networkType="..self.networkType)
    self:reConnectSocket()
    if newNetworkType == cc.NET_INVALID or newNetworkType ~= self.networkType then
        if self.onWebsocketErrorHandler ~= nil then
            --print("=======onWebsocketErrorHandler======")
            self.onWebsocketErrorHandler(self.closeData)
        end
    else
        if self.onWebsocketCloseHandler ~= nil then
            self.onWebsocketCloseHandler(self.closeData)
            --print("=======onWebsocketCloseHandler======")
        end
    end
    self.networkType = newNetworkType
end

function _fixWebSocket:onWebsocketError(data)
    self.isConnecting = nil
    if self._autoReconnect and not self.closeMySelf then
        self:reConnectSocket(true)
    end
    --print("=======onWebsocketError======")
    if self.onWebsocketErrorHandler ~= nil then
        self.onWebsocketErrorHandler(data)
    end
end

function _fixWebSocket:unregisterScriptHandler(wsEventId)
    if not self.webSocket then
        print(TAG.." unregisterScriptHandler self.webSocket = nil wsEventId = "..wsEventId)
        return
    end
    self.webSocket:unregisterScriptHandler(wsEventId)
end

return _fixWebSocket
